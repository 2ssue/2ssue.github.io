---
title:  "[프로그래머스] 다리를 지나는 트럭"
date:   2019-06-11 13:56:24 +0900
categories: algorithm
tags: programmers
classes: wide
---

[프로그래머스 코딩테스트 연습_스택/큐_다리를 지나는 트럭](https://programmers.co.kr/learn/courses/30/lessons/42583?language=java)

블로그에 가장 방문자가 많은 포스트가 이 포스트이다.  
그래서 종종 읽어보는데 너무 복잡하게 푼 것 같아서 다시 풀어보았다.  
  
## 변경 풀이 (19.06.11)
  
트럭은 가장 앞에 들어온 트럭이 가장 먼저 나간다. 따라서 Queue를 사용해 계산했다.  
  
트럭이 들어가는 것은 따로 저장하지 않고 다리에서 대기하는 시간만 큐에 저장했다. 트럭이 들어가는 것은 다리 안의 트럭 무게를 트럭이 나갔을 때 빼 주기 위해 이를 계산할 `idx`가 존재하기 때문에 굳이 또 한번의 작업이 필요하지 않다고 생각했기 때문이다. 또, 나가는 트럭은 항상 맨 앞의 트럭이기 때문에 가장 앞의 대기 시간을 확인하기만 하면 나가는 트럭을 쉽게 처리할 수 있다고 생각해 Queue를 사용했다.  

> ### 풀이과정
  
코드의 동작 방식은 간단하다.  
  
다리에 현재 가르키는 트럭이 들어가도 되는지 확인하고, 들어갈 수 있다면 `idx`가 다음 트럭을 가리키게 한 뒤 현재 트럭이 들어간다. 이 때 들어가는 값은 트럭의 무게 값이 아닌 트럭의 이동 시간 값이다.   
  
트럭이 다리 안으로 들어가면 `increaseTime()` 함수를 통해 트럭의 이동시간을 늘린다. 이 때 트럭의 이동시간이 `bridge_length`와 같아지면 트럭을 다리에서 빼낸다.  
  
이 같은 동작이 `idx`가 전체 트럭의 수와 같아질 때까지 계속 반복된다.  
그런데 반복문 안에서는 마지막 트럭의 이동시간이 계산되지 않기 때문에, 반복문이 종료되면 마지막 트럭의 이동시간을 더해준 뒤 모든 동작을 마무리 한다.  

이 코드는 bridge_length가 2이고 weight가 10, truck이 {7,4,5,6} 일 때 아래와 같이 동작한다.  
  
|초|다리를 나간 트럭|다리에 있는 트럭|다리 상주 시간|대기 트럭|idx|
|1||{7}|{1}|4,5,6|1|
|2||{7}|{2}|4,5,6|1|
|3|{7}|{4}|{1}|5, 6|2|
|4|{7}|{4,5}|{2,1}|6|3|
|5|{7,4}|{5}|{2}|6|3|
|6|{7,4,5}|{6}|{1}|4|

이후 마지막 트럭이 다리를 지나는 시간이 반복문을 통해 계산되지 않았으므로, 이 값을 직접 answer에 더해준다.  

```java
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    public void increaseTime(Queue<Integer> time) {
        int queueSize = time.size();
        
        for(int i = 0; i < queueSize; i++) {
            time.offer(time.poll() + 1);
        }
    }
    
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        int answer = 0;
         
        int bridge_weight = 0;
        Queue<Integer> truck_time = new LinkedList<>();
        int idx = 0;
         
        while(idx < truck_weights.length) {
            answer++;
             
            int curTruck = truck_weights[idx];
             
            if(bridge_weight + curTruck <= weight) {
                idx++;
                bridge_weight += curTruck;
                truck_time.offer(0);
            }
             
            increaseTime(truck_time);
             
            if(truck_time.peek() == bridge_length) {
                bridge_weight -= truck_weights[idx - truck_time.size()];
                truck_time.poll();
            }
        }
         
        answer += bridge_length;
         
        return answer;
    }
}
```

## 이전 풀이 (19.03.01)

가장 먼저 들어온 트럭이 가장 먼저 나가게 되는 구조이다. 따라서 Queue를 사용하였다.  

> ### 변수 선언

```java
int[] delay; //Queue에 머물러 있는 시간을 계산하기 위한 배열
int front; //Queue에 들어가있는 맨 앞 원소의 배열 인덱스
int rear; //Queue에 들어가있는 맨 마지막 원소의 배열 인덱스
int second; //시간을 계산할 변수
```

> ### 풀이과정

_0번째 배열은 무조건 들어갈 수 있기 때문에 반복문 전에 미리 Queue에 넣는다._  
`front` 부터 `rear` 까지 `delay[i]`값을 증가시키면서 `delay[i]`가 `bridge_length`보다 큰지 확인한다.  
만약 `bridge_length`보다 커지면, Queue에서 빼고 그 원소가 빠졌음을 알기 위해 `front`값을 증가시킨다.  
  
그 다음으로는 트럭이 더 들어갈 수 있는지 확인한다.  
  
Queue에 들어가있는 원소의 합과 다음 원소가 `weight`이하인지 확인한다.  
만약 `weight`이하라면 그 원소를 Queue에 넣고, `rear`값과 `delay[rear]`를 증가시킨다.
  
Queue가 비면 반복문을 종료한다.
  
```java
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    public int sum(int[] arr, int idx1, int idx2){
        int sum = 0;
        
        for(int i = idx1; i <= idx2; i++){
            sum += arr[i];    
        }
        
        return sum;
    }
    
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        int answer = 0;
        int second = 0;
        
        Queue que = new LinkedList();
        int[] delay = new int[truck_weights.length];
        int front = 0;
        int rear = 0;
        
        que.offer(truck_weights[0]);
        second++;
        delay[0]++;
        
        while((!que.isEmpty())){
            second++;
            for(int i = front; i <= rear; i++){
                delay[i]++;
                if(delay[i] > bridge_length){
                    que.poll();
                    front++;
                }
            }
            if (!(rear + 1 == truck_weights.length)){
                if((sum(truck_weights, front, rear) + truck_weights[rear + 1]) <= weight){
                    que.offer(truck_weights[++rear]);
                    delay[rear]++;
                }
            }
        }
        answer = second;
        
        return answer;
    }
}
```